<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <title>Poly Whales - Quanty</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <!-- Ionicons -->
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
</head>

<body>

    <nav class="navbar">
        <div class="logo" style="color: #4a90e2;"><a href="/">Quanty</a></div>
        <div class="nav-links">
            <a href="/about">About</a>
            <a href="/whales">Poly Whales</a>
            <a href="/insider">Insider Trades</a>
            <a href="/terms">Terms</a>
            <a href="/how-to-use">How to Use</a>
            <a href="/chat">Web agent</a>
        </div>
        <div class="nav-actions">
            <a href="https://github.com/lopushok9/gemini_quant" class="download-btn">Download</a>
            <button class="mobile-menu-btn" onclick="toggleMenu()">
                <span></span>
                <span></span>
            </button>
        </div>
    </nav>

    <div id="mobileBackdrop" class="mobile-menu-backdrop" onclick="toggleMenu()"></div>
    <div id="mobileMenu" class="mobile-menu-sidebar">
        <div class="mobile-menu-header">
            <button class="close-menu-btn" onclick="toggleMenu()">&times;</button>
        </div>
        <a href="/">Home</a>
        <a href="/about">About</a>
        <a href="/whales">Poly Whales</a>
        <a href="/insider">Insider Trades</a>
        <a href="/how-to-use">How to Use</a>
        <a href="/chat">Web agent</a>
        <a href="/terms">Terms</a>
        <a href="https://github.com/lopushok9/gemini_quant"
            style="color: #4A90E2; border-bottom: none; margin-top: auto; font-weight: 700;">Download App</a>
    </div>

    <script>
        function toggleMenu() {
            document.getElementById('mobileMenu').classList.toggle('active');
            document.getElementById('mobileBackdrop').classList.toggle('active');
            document.body.style.overflow = document.body.style.overflow === 'hidden' ? '' : 'hidden';
        }
    </script>

    <main class="whales-page-container">
        <header class="whales-header">
            <div class="whales-nav-tabs">
                <a href="/whales" class="whales-nav-tab active">Large Trades</a>
                <a href="/leaderboard" class="whales-nav-tab">Top Traders</a>
            </div>
            <h1>Poly Whales</h1>
            <p>Real-time large positions from Polymarket </p>
        </header>

        <div class="whales-filters">
            <div class="filter-group">
                <label for="minSizeSelect" class="filter-label">Min. Purchase:</label>
                <select id="minSizeSelect" class="filter-select">
                    <option value="1000">$1,000</option>
                    <option value="3000">$3,000</option>
                    <option value="5000">$5,000</option>
                    <option value="10000">$10,000</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="outcomeFilter" class="filter-label">Outcome:</label>
                <select id="outcomeFilter" class="filter-select">
                    <option value="all">All</option>
                    <option value="yes">YES Only</option>
                    <option value="no">NO Only</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="probFilter" class="filter-label">Probability:</label>
                <select id="probFilter" class="filter-select">
                    <option value="all">All Prices</option>
                    <option value="middle">10% - 90% (Whales)</option>
                </select>
            </div>

            <div class="filter-group search-group">
                <label for="marketSearch" class="filter-label">Search Market:</label>
                <input type="text" id="marketSearch" class="filter-input" placeholder="Search (e.g. Bitcoin)...">
            </div>
        </div>

        <div id="whalesFeed" class="whales-feed">
            <!-- Feed will be populated by JS -->
            <div id="loadingState" style="text-align: center; color: #999; padding: 2rem;">
                <p>Waiting for large trades...</p>
            </div>
        </div>
    </main>

    <footer class="site-footer">
        <div class="footer-content">
            <div class="footer-links">
                <a href="/about">About</a>
                <a href="/terms">Terms</a>
                <a href="/how-to-use">How to Use</a>
            </div>
            <div class="copyright">
                &copy; 2025 Quanty. DYOR.
            </div>
        </div>
        <div class="footer-ca">CA: 5FYMEwjj1jHu4R2f9amsGhzGnyH2PghQ5dynW79tpump</div>
    </footer>

    <script>
        let currentMinSize = 1000;
        let currentOutcome = 'all';
        let currentProbMode = 'all';
        let currentSearch = '';

        const feedContainer = document.getElementById('whalesFeed');
        const marketCache = new Map();

        function removeLoadingState() {
            const ls = document.getElementById('loadingState');
            if (ls) ls.remove();
        }

        async function fetchMarketDetails(conditionId) {
            if (marketCache.has(conditionId)) return marketCache.get(conditionId);

            try {
                const response = await fetch(`https://clob.polymarket.com/markets/${conditionId}`);
                if (!response.ok) throw new Error('Market not found');
                const data = await response.json();
                marketCache.set(conditionId, data);
                return data;
            } catch (err) {
                console.error('Error fetching market details:', err);
                return null;
            }
        }

        function createWhaleCard(trade, market) {
            const notional = trade.size * trade.price;

            // Safe outcome check
            const outcome = (trade.outcome || '').toString().toLowerCase();
            const isYes = outcome === 'yes' || outcome === 'true' || outcome === 'up';
            const outcomeClass = isYes ? 'whale-outcome-yes' : 'whale-outcome-no';
            const displayOutcome = trade.outcome ? trade.outcome.toUpperCase() : 'BUY';

            // Timestamp handling: Polymarket Data API uses seconds, JS uses milliseconds
            let ts = trade.timestamp || Date.now();
            if (ts < 10000000000) ts *= 1000; // Heuristic: if < 10B, it's seconds
            const timeStr = new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            // Format address for display
            const addr = trade.proxyWallet || 'Unknown';
            const shortAddr = addr.length > 10 ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : addr;

            const card = document.createElement('div');
            card.className = 'whale-card';
            card.innerHTML = `
                <div class="whale-market-info">
                    <div class="whale-market-icon">
                        ${market?.image ? `<img src="${market.image}" alt="market">` : '<ion-icon name="trending-up-outline"></ion-icon>'}
                    </div>
                    <div class="whale-market-question">${market?.question || 'Unknown Market'}</div>
                    <div class="whale-outcome ${outcomeClass}">${displayOutcome}</div>
                </div>
                <div class="whale-trade-details">
                    <div class="whale-stats">
                        <div class="whale-stat-item">
                            <span class="whale-stat-label">Size</span>
                            <span class="whale-stat-value">$${notional.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</span>
                        </div>
                        <div class="whale-stat-item">
                            <span class="whale-stat-label">Price</span>
                            <span class="whale-stat-value">${(trade.price * 100).toFixed(1)}%</span>
                        </div>
                    </div>
                    <div class="whale-wallet-info">
                        <span class="whale-stat-label" style="display: block; margin-right: 8px;">Wallet:</span>
                        <div class="whale-wallet-address" onclick="copyToClipboard('${addr}', this)" title="Click to copy">
                            ${shortAddr}
                        </div>
                        <span class="whale-timestamp">${timeStr}</span>
                    </div>
                </div>
            `;
            return card;
        }

        window.copyToClipboard = (text, el) => {
            navigator.clipboard.writeText(text);
            const originalText = el.innerText;
            el.innerText = 'Copied!';
            el.style.color = '#008134';
            setTimeout(() => {
                el.innerText = originalText;
                el.style.color = '';
            }, 1500);
        };

        function connectWS() {
            const ws = new WebSocket('wss://ws-live-data.polymarket.com');

            ws.onopen = () => {
                console.log('Connected to Polymarket RTDS');
                ws.send(JSON.stringify({
                    action: "subscribe",
                    subscriptions: [{
                        topic: "activity",
                        type: "trades"
                    }]
                }));
            };

            ws.onmessage = async (event) => {
                if (!event.data) return;

                try {
                    const msg = JSON.parse(event.data);
                    if (msg.topic !== 'activity' || msg.type !== 'trades' || !msg.payload) return;

                    const trade = msg.payload;
                    const price = parseFloat(trade.price);
                    const notional = parseFloat(trade.size) * price;
                    const outcome = (trade.outcome || '').toLowerCase();
                    const side = (trade.side || '').toUpperCase();
                    const conditionId = trade.conditionId || trade.condition_id;

                    // Check all filters
                    const matchesSize = notional >= currentMinSize;
                    const matchesOutcome = currentOutcome === 'all' || outcome === currentOutcome;
                    const matchesProb = currentProbMode === 'all' || (price >= 0.10 && price <= 0.90);

                    if (side === 'BUY' && matchesSize && matchesOutcome && matchesProb && conditionId) {
                        const market = await fetchMarketDetails(conditionId);

                        // Search filter
                        const matchesSearch = !currentSearch || market?.question.toLowerCase().includes(currentSearch);

                        // Only show if market is still open/active and matches search
                        if (market && !market.closed && matchesSearch) {
                            removeLoadingState();

                            const formattedTrade = {
                                ...trade,
                                conditionId: conditionId, // normalize
                                size: parseFloat(trade.size),
                                price: price,
                                timestamp: trade.timestamp || trade.time // Ensure timestamp is passed
                            };

                            const card = createWhaleCard(formattedTrade, market);
                            feedContainer.prepend(card);

                            // Keep only last 50 trades
                            if (feedContainer.children.length > 50) {
                                feedContainer.removeChild(feedContainer.lastChild);
                            }
                        }
                    }
                } catch (err) {
                    console.error('Error processing WS message:', err);
                }
            };

            ws.onclose = () => {
                console.log('WS closed, reconnecting...');
                setTimeout(connectWS, 3000);
            };

            ws.onerror = (err) => {
                console.error('WS Error:', err);
            };
        }

        // Initial load of recent trades from Polymarket Data API
        let lastLoadId = 0;
        async function loadInitialTrades() {
            const currentLoadId = ++lastLoadId;
            console.log('[Whales] Loading historical trades...');

            try {
                removeLoadingState();
                feedContainer.innerHTML = '<div id="loadingState" style="text-align: center; color: #999; padding: 2rem;"><p>Loading whale history...</p></div>';

                let loadedCount = 0;
                const maxHistoryTrades = 10;
                const allTrades = [];

                // Fetch trades in batches until we have enough or run out
                // Start from now and go backwards up to 6 hours
                const nowSec = Math.floor(Date.now() / 1000);
                const sixHoursAgoSec = nowSec - (6 * 60 * 60);

                // First batch: most recent trades
                const batchUrls = [
                    `https://data-api.polymarket.com/trades?limit=1000`,
                    `https://data-api.polymarket.com/trades?limit=1000&before=${nowSec - 3600}`, // 1h ago
                    `https://data-api.polymarket.com/trades?limit=1000&before=${nowSec - 7200}`, // 2h ago
                ];

                // Fetch batches in parallel
                const responses = await Promise.allSettled(
                    batchUrls.map(url => fetch(url).then(r => r.ok ? r.json() : []))
                );

                // Check if this load is still relevant
                if (currentLoadId !== lastLoadId) return;

                // Collect all trades from successful responses
                for (const result of responses) {
                    if (result.status === 'fulfilled' && Array.isArray(result.value)) {
                        allTrades.push(...result.value);
                    }
                }

                console.log(`[Whales] Fetched ${allTrades.length} total trades from API`);

                // Remove duplicates by trade ID/hash
                const seen = new Set();
                const uniqueTrades = allTrades.filter(t => {
                    const key = t.id || t.transaction_hash || `${t.asset_id}-${t.match_time}-${t.size}`;
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return true;
                });

                // Sort by timestamp descending (newest first)
                uniqueTrades.sort((a, b) => {
                    const tsA = new Date(a.match_time || a.timestamp || 0).getTime();
                    const tsB = new Date(b.match_time || b.timestamp || 0).getTime();
                    return tsB - tsA;
                });

                console.log(`[Whales] ${uniqueTrades.length} unique trades after deduplication`);

                // Clear loading state
                removeLoadingState();

                for (const trade of uniqueTrades) {
                    if (loadedCount >= maxHistoryTrades) break;

                    const price = parseFloat(trade.price || '0');
                    const size = parseFloat(trade.size || '0');
                    const notional = size * price;
                    const outcome = (trade.outcome || '').toLowerCase();
                    const side = (trade.side || '').toUpperCase();
                    const conditionId = trade.conditionId || trade.condition_id || trade.market;

                    // Apply filters: BUY side, minimum size, outcome, probability
                    const matchesSize = notional >= currentMinSize;
                    const matchesOutcome = currentOutcome === 'all' || outcome === currentOutcome;
                    const matchesProb = currentProbMode === 'all' || (price >= 0.10 && price <= 0.90);

                    if (side === 'BUY' && matchesSize && matchesOutcome && matchesProb && conditionId) {
                        const market = await fetchMarketDetails(conditionId);

                        // Check if still relevant after async call
                        if (currentLoadId !== lastLoadId) return;

                        // Search filter and market validity check
                        const matchesSearch = !currentSearch || market?.question?.toLowerCase().includes(currentSearch);

                        if (market && !market.closed && matchesSearch) {
                            // Parse timestamp properly
                            let timestamp = trade.match_time || trade.created_at || trade.timestamp;
                            if (timestamp) {
                                // If it's a string date, parse it
                                if (typeof timestamp === 'string' && timestamp.includes('-')) {
                                    timestamp = new Date(timestamp).getTime();
                                } else {
                                    const numTs = typeof timestamp === 'string' ? parseInt(timestamp, 10) : timestamp;
                                    timestamp = numTs < 10000000000 ? numTs * 1000 : numTs;
                                }
                            } else {
                                timestamp = Date.now();
                            }

                            const formattedTrade = {
                                ...trade,
                                conditionId: conditionId,
                                size: size,
                                price: price,
                                outcome: trade.outcome || 'Unknown',
                                proxyWallet: trade.owner || trade.maker_address || trade.taker_address || 'Unknown',
                                timestamp: timestamp
                            };

                            const card = createWhaleCard(formattedTrade, market);
                            // Add a subtle indicator that this is historical
                            card.classList.add('whale-card-historical');
                            feedContainer.appendChild(card);
                            loadedCount++;
                        }
                    }
                }

                // If we loaded history, add a separator before live trades
                if (loadedCount > 0) {
                    const separator = document.createElement('div');
                    separator.className = 'whale-history-separator';
                    separator.innerHTML = '<span>History loaded â€” Live trades will appear above</span>';
                    feedContainer.appendChild(separator);
                } else {
                    // If no history found, show waiting message
                    if (!feedContainer.querySelector('#loadingState') && feedContainer.children.length === 0) {
                        feedContainer.innerHTML = '<div id="loadingState" style="text-align: center; color: #999; padding: 2rem;"><p>No recent whale trades found matching $' + currentMinSize.toLocaleString() + '+ filter. Waiting for live trades...</p></div>';
                    }
                }

                console.log(`[Whales] Loaded ${loadedCount} historical trades`);

            } catch (error) {
                console.error('[Whales] Error loading history:', error);
                // Show waiting message on error
                if (!feedContainer.querySelector('#loadingState') && feedContainer.children.length === 0) {
                    feedContainer.innerHTML = '<div id="loadingState" style="text-align: center; color: #999; padding: 2rem;"><p>Waiting for large trades...</p></div>';
                }
            }
        }

        // Filter handling
        const refreshFeed = () => {
            feedContainer.innerHTML = '';
            feedContainer.appendChild(createLoadingElement());
            loadInitialTrades();
        };

        document.getElementById('minSizeSelect').addEventListener('change', (e) => {
            currentMinSize = parseInt(e.target.value);
            refreshFeed();
        });

        document.getElementById('outcomeFilter').addEventListener('change', (e) => {
            currentOutcome = e.target.value;
            refreshFeed();
        });

        document.getElementById('probFilter').addEventListener('change', (e) => {
            currentProbMode = e.target.value;
            refreshFeed();
        });

        let searchTimeout;
        document.getElementById('marketSearch').addEventListener('input', (e) => {
            currentSearch = e.target.value.toLowerCase().trim();
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(refreshFeed, 500); // 500ms debounce
        });

        function createLoadingElement() {
            const div = document.createElement('div');
            div.id = 'loadingState';
            div.style = 'text-align: center; color: #999; padding: 2rem;';
            div.innerHTML = '<p>Waiting for large trades...</p>';
            return div;
        }

        // Execution
        loadInitialTrades();
        connectWS();
    </script>
</body>

</html>